{
  // --------------------------Tempate Snippets Start----------------------- //
  //TODO: Starting Template
  "starting template": {
    "prefix": "cpp",
    "body": [
      "//!-----------------------------------------------------!//",
      "//!              Author: YUSUF REZA HASNAT              !//",
      "//!             Created: ${CURRENT_DATE}|${CURRENT_MONTH}|${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}            !//",
      "//!-----------------------------------------------------!//",
      "",
      "#pragma GCC optimize(\"O3\")",
      "#include<bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "#define int   long long",
      "#define float long double",
      "#define vf(v) (v).begin(), (v).end()",
      "#define vr(v) (v).rbegin(), (v).rend()",
      "#define endl \"\\n\"",
      "",
      "const int mod = 1e9 + 7;",
      "const int inf = 1e18;",
      "",
      "void solve() {",
      "    ${2:}",
      "}",
      "",
      "int32_t main() {",
      "    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);",
      "    int t = 1;",
      "    ${1://}cin >> t;",
      "    for (int i = 1; i <= t; i++){",
      "        solve(); ",
      "    }",
      "    return 0;",
      "}",
    ],
    "description": "starting template"
  },
  //TODO: Debug Template
  "debug": {
    "prefix": "debug",
    "body": [
      "#ifndef ONLINE_JUDGE",
      "#include \"debug.h\"",
      "#else ",
      "#define dbg(x...)",
      "#define dbgc(x...)",
      "#endif",
    ],
    "description": "debug template"
  },
  //TODO: File Input Output
  "File Input Output": {
    "prefix": "fileIO",
    "body": [
      "freopen(\"input.txt\", \"r\", stdin);",
      "freopen(\"output.txt\", \"w\", stdout);",
    ],
    "description": "file input output"
  },
  //TODO: Order Set Template
  "order set template": {
    "prefix": "order set template",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "template <typename T> using o_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "template <typename T> using o_set_g = tree<T, null_type, greater<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "template <typename T> using o_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "template <typename T> using o_multiset_g = tree<T, null_type, greater_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    ],
    "description": "find_by_order and order_of_key"
  },
  // --------------------------Tempate Snippets End----------------------- //
  // --------------------------Math Snippets Start------------------------ //
  //TODO: Check a year is leap year or not
  "Leap Year": {
    "prefix": "leapYear",
    "body": [
      "bool isLeapYear(int n) {",
      "    if (n % 100 == 0) {",
      "        if (n % 400 == 0)",
      "            return true;",
      "        return false;",
      "    }",
      "    if (n % 4 == 0),",
      "        return true;",
      "    return false;",
      "}",
    ],
    "description": "time complexity O(1)"
  },
  //TODO: Check a number is prime or not
  "Check prime or not?": {
    "prefix": "isprime",
    "body": [
      "bool isPrime(int n){",
      "    if (n < 2)",
      "        return false;",
      "    if (n <= 3)",
      "        return true;",
      "    if (!(n % 2) || !(n % 3))",
      "        return false;",
      "    for (int i = 5; i * i <= n; i += 6)",
      "        if (!(n % i) || !(n % (i + 2))) ",
      "            return false;",
      "    return true;",
      "}",
      "",
    ],
    "description": "time complexity O(sqrt(n))"
  },
  //TODO: Prime Factoralization
  "Prime Factoralization": {
    "prefix": "primeFactoralization",
    "body": [
      "// smallest prime factor of a number.",
      "int factor(int n){",
      "    if (n % 2 == 0)",
      "        return 2;",
      "    for (int a = 3; a * a <= n; a++){",
      "        if (n % a == 0)",
      "            return a;",
      "    }",
      "    return n;",
      "}",
      "// complete factorization. call the remaining part in main function",
      "// here n is the number to be factorized",
      "while (n>1){",
      "    int r = factor(n);",
      "    n /= r;",
      "}",
    ],
    "description": "time complexity O(sqrt(n))"
  },
  //TODO: Seive of Eratosthenes
  "Seive of Eratosthenes": {
    "prefix": "seive",
    "body": [
      "const int N = 1e7 + 5;",
      "int prime[N];",
      "void sieveOfEratosthenes() {",
      "    for (int i = 2; i < N; i++)",
      "        prime[i] = 1;",
      "    for (int i = 4; i < N; i += 2)",
      "        prime[i] = 0;",
      "    for (int i = 3; i * i < N; i++) {",
      "        if (prime[i]) {",
      "            for (int j = i * i; j < N; j += i * 2)",
      "                prime[j] = 0;",
      "        }",
      "    }",
      "}"
    ],
    "description": "time complexity of seive O(nlog(logn)) and space complexity O(n)"
  },
  //TODO: Smallest Prime Factor Seive
  "Smallest Prime Factor Using Seive": {
    "prefix": "spf",
    "body": [
      "const int N = 1e7 + 5;",
      "int spf[N];",
      "void smallestPrimeFactorUsingSeive() {",
      "    for (int i = 2; i < N; i++) {",
      "        if (spf[i] == 0) {",
      "            for (int j = i; j < N; j += i) {",
      "                if (spf[j] == 0)",
      "                    spf[j] = i;",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "time complexity O(nlog(logn))"
  },
  //TODO: Nth Prime Number
  "Nth Prime Number": {
    "prefix": "nthPrime",
    "body": [
      "const int MX = 86200005;",
      "vector<int> nth_prime;",
      "bitset<MX> visited;",
      "void optimized_prime() {",
      "    nth_prime.push_back(2);",
      "    for (int i = 3; i < MX; i += 2) {",
      "        if (visited[i])",
      "            continue;",
      "        nth_prime.push_back(i);",
      "        if (1ll * i * i > MX)",
      "            continue;",
      "        for (int j = i * i; j < MX; j += i + i)",
      "            visited[j] = true;",
      "    }",
      "}",
    ],
    "description": "time complexity O(nlog(logn))"
  },
  //TODO: Binary Exponential
  "Binary Exponential": {
    "prefix": "binaryExponential",
    "body": [
      "int binaryExp(int base, int power, int MOD = mod) {",
      "    int res = 1;",
      "    while (power) {",
      "        if (power & 1)",
      "            res = (res * base) % MOD;",
      "        base = ((base % MOD) * (base % MOD)) % MOD;",
      "        power /= 2;",
      "    }",
      "    return res;",
      "}",
      "",
    ],
    "description": "time complexity O(logn)"
  },
  //TODO: Modular addition:
  "modular addition": {
    "prefix": "mod_add",
    "body": [
      "int mod_add(int a, int b, int MOD = mod) {",
      "    a = a % MOD, b = b % MOD;",
      "    return (((a + b) % MOD) + MOD) % MOD;",
      "}",
      "",
    ],
    "description": "time complexity O(1)"
  },
  //TODO: Modular subtraction
  "modular subtraction": {
    "prefix": "mod_sub",
    "body": [
      "int mod_sub(int a, int b, int MOD = mod) {",
      "    a = a % MOD, b = b % MOD;",
      "    return (((a - b) % MOD) + MOD) % MOD;",
      "}",
      "",
    ],
    "description": "time complexity O(1)"
  },
  //TODO: Modular multipication
  "modular multipication": {
    "prefix": "mod_mul",
    "body": [
      "int mod_mul(int a, int b, int MOD = mod) {",
      "    a = a % MOD, b = b % MOD;",
      "    return (((a * b) % MOD) + MOD) % MOD;",
      "}",
      "",
    ],
    "description": "time complexity O(1)"
  },
  //TODO: Modular division
  "modular division": {
    "prefix": "mod_div",
    "body": [
      "int binaryExp(int base, int power, int MOD = mod) {",
      "    int res = 1;",
      "    while (power) {",
      "        if (power & 1)",
      "            res = (res * base) % MOD;",
      "        base = ((base % MOD) * (base % MOD)) % MOD;",
      "        power /= 2;",
      "    }",
      "    return res;",
      "}",
      "int mminvprime(int a, int b) { return binaryExp(a, b - 2, b); }",
      "int mod_mul(int a, int b, int MOD = mod) {",
      "    a = a % MOD, b = b % MOD;",
      "    return (((a * b) % MOD) + MOD) % MOD;",
      "}",
      "int mod_div(int a, int b, int MOD = mod) {",
      "    a = a % MOD, b = b % MOD;",
      "    return (mod_mul(a, mminvprime(b, MOD), MOD) + MOD) % MOD;",
      "}  // only for prime MOD",
      "",
    ],
    "description": "time complexity O(logn)"
  },
  //TODO: nCr
  "nCr": {
    "prefix": "nCr",
    "body": [
      "int mod = 1e9 + 7;",
      "const int MAX = 1e7 + 5;",
      "vector<int> fact(MAX), ifact(MAX), inv(MAX);",
      "",
      "void factorial() {",
      "    inv[1] = fact[0] = ifact[0] = 1;",
      "    for (int i = 2; i < MAX; i++)",
      "        inv[i] = inv[mod % i] * (mod - mod / i) % mod;",
      "    for (int i = 1; i < MAX; i++)",
      "        fact[i] = (fact[i - 1] * i) % mod;",
      "    for (int i = 1; i < MAX; i++)",
      "        ifact[i] = ifact[i - 1] * inv[i] % mod;",
      "}",
      "",
      "int nCr(int n, int r) {",
      "    if (r < 0 || r > n)",
      "        return 0;",
      "    return (int)fact[n] * ifact[r] % mod * ifact[n - r] % mod;",
      "}",
      "",
    ],
    "description": "time complexity O(MAX) for precomputation and O(1) for nCr"
  },
  // --------------------------Math Snippets End----------------------- //
  // ------------------------Data Structure Start---------------------- //
  //TODO: KMP Algorithm
  "KMP": {
    "prefix": "KMP algorithm",
    "body": [
      "vector<int> createLPS(string pattern) {",
      "    vector<int> lps(pattern.length());",
      "    int index = 0;",
      "    for (int i = 1; i < pattern.length();) {",
      "        if (pattern[index] == pattern[i]) {",
      "            lps[i] = index + 1;",
      "            index++, i++;",
      "        }",
      "        else {",
      "            if (index != 0)",
      "                index = lps[index - 1];",
      "            else",
      "                lps[i] = index, i++;",
      "        }",
      "    }",
      "    return lps;",
      "}",
      "int kmp(string text, string pattern) {",
      "    int cnt_of_match = 0;",
      "    vector<int> lps = createLPS(pattern);",
      "    int i = 0, j = 0;",
      "    // i -> text, j -> pattern",
      "    while (i < text.length()) {",
      "        if (text[i] == pattern[j])",
      "            i++, j++;",
      "        else {",
      "            if (j != 0)",
      "                j = lps[j - 1];",
      "            else",
      "                i++;",
      "        }",
      "        if (j == pattern.length()) {",
      "            cnt_of_match++;",
      "            // the index where match found -> (i - pattern.length());",
      "            j = lps[j - 1];",
      "        }",
      "    }",
      "    return cnt_of_match;",
      "}",
      "",
    ],
    "description": "time complexity O(n+m)"
  },
  //TODO: Segment Tree
  "Segment Tree": {
    "prefix": "segment_tree",
    "body": [
      "class SEGMENT_TREE {",
      "   public:",
      "    vector<int> v;",
      "    vector<int> seg;",
      "    SEGMENT_TREE(int n) {",
      "        v.resize(n + 5);",
      "        seg.resize(4 * n + 5);",
      "    }",
      "    //! intially: ti = 1, low = 1, high = n(number of elements in the array);",
      "    void build(int ti, int low, int high) {",
      "        if (low == high) {",
      "            seg[ti] = v[low];",
      "            return;",
      "        }",
      "        int mid = (low + high) / 2;",
      "        build(2 * ti, low, mid);",
      "        build(2 * ti + 1, mid + 1, high);",
      "        seg[ti] = (seg[2 * ti] + seg[2 * ti + 1]);",
      "    }",
      "    //! intially: ti = 1, low = 1, high = n(number of elements in the array), (ql & qr) = user input in 1 based indexing;",
      "    int find(int ti, int tl, int tr, int ql, int qr) {",
      "        if (tl > qr || tr < ql) {",
      "            return 0;",
      "        }",
      "        if (tl >= ql and tr <= qr)",
      "            return seg[ti];",
      "        int mid = (tl + tr) / 2;",
      "        int l = find(2 * ti, tl, mid, ql, qr);",
      "        int r = find(2 * ti + 1, mid + 1, tr, ql, qr);",
      "        return (l + r);",
      "    }",
      "    //! intially: ti = 1, tl = 1, tr = n(number of elements in the array), id = user input in 1 based indexing, val = updated value;",
      "    void update(int ti, int tl, int tr, int id, int val) {",
      "        if (id > tr or id < tl)",
      "            return;",
      "        if (id == tr and id == tl) {",
      "            seg[ti] = val;",
      "            return;",
      "        }",
      "        int mid = (tl + tr) / 2;",
      "        update(2 * ti, tl, mid, id, val);",
      "        update(2 * ti + 1, mid + 1, tr, id, val);",
      "        seg[ti] = (seg[2 * ti] + seg[2 * ti + 1]);",
      "    }",
      "   // use 1 based indexing for input and queries and update;",
      "};",
      ""
    ],
    "description": "time complexity Build: O(nlogn), Query: O(logn), Update: O(logn)"
  },
  "Big Integer": {
    "prefix": "BigInteger",
    "body": [
      "struct BigInteger {",
      "    string str;",
      "    // Constructor to initialize",
      "    // BigInteger with a string",
      "    BigInteger(string s) { str = s; }",
      "    // Overload + operator to add",
      "    // two BigInteger objects",
      "    BigInteger operator+(const BigInteger& b) {",
      "        string a = str, c = b.str;",
      "        int alen = a.length(), clen = c.length();",
      "        int n = max(alen, clen);",
      "        if (alen > clen)",
      "            c.insert(0, alen - clen, '0');",
      "        else if (alen < clen)",
      "            a.insert(0, clen - alen, '0');",
      "        string res(n + 1, '0');",
      "        int carry = 0;",
      "        for (int i = n - 1; i >= 0; i--) {",
      "            int digit = (a[i] - '0') + (c[i] - '0') + carry;",
      "            carry = digit / 10;",
      "            res[i + 1] = digit % 10 + '0';",
      "        }",
      "        if (carry == 1) {",
      "            res[0] = '1';",
      "            return BigInteger(res);",
      "        }",
      "        else ",
      "            return BigInteger(res.substr(1));",
      "    }",
      "    ",
      "    // Overload - operator to subtract",
      "    // first check which number is greater and then subtract",
      "    BigInteger operator-(const BigInteger& b) {",
      "        string a = str;",
      "        string c = b.str;",
      "        int alen = a.length(), clen = c.length();",
      "        int n = max(alen, clen);",
      "        if (alen > clen)",
      "            c.insert(0, alen - clen, '0');",
      "        else if (alen < clen)",
      "            a.insert(0, clen - alen, '0');",
      "        if (a < c) {",
      "            swap(a, c);",
      "            swap(alen, clen);",
      "        }",
      "        string res(n, '0');",
      "        int carry = 0;",
      "        for (int i = n - 1; i >= 0; i--) {",
      "            int digit = (a[i] - '0') - (c[i] - '0') - carry;",
      "            if (digit < 0) {",
      "                digit += 10;",
      "                carry = 1;",
      "            }",
      "            else {",
      "                carry = 0;",
      "            }",
      "            res[i] = digit + '0';",
      "        }",
      "        // remove leading zeros",
      "        int i = 0;",
      "        while (i < n && res[i] == '0')",
      "            i++;",
      "        if (i == n)",
      "            return BigInteger(\"0\");",
      "        return BigInteger(res.substr(i));",
      "    }",
      "    ",
      "    // Overload * operator to multiply",
      "    // two BigInteger objects",
      "    BigInteger operator*(const BigInteger& b) {",
      "        string a = str, c = b.str;",
      "        int alen = a.length(), clen = c.length();",
      "        int n = alen + clen;",
      "        string res(n, '0');",
      "        for (int i = alen - 1; i >= 0; i--) {",
      "            int carry = 0;",
      "            for (int j = clen - 1; j >= 0; j--) {",
      "                int digit = (a[i] - '0') * (c[j] - '0') + (res[i + j + 1] - '0') + carry;",
      "                carry = digit / 10;",
      "                res[i + j + 1] = digit % 10 + '0';",
      "            }",
      "            res[i] += carry;",
      "        }",
      "        int i = 0;",
      "        while (i < n && res[i] == '0')",
      "            i++;",
      "        if (i == n)",
      "            return BigInteger(\"0\");",
      "        return BigInteger(res.substr(i));",
      "    }",
      "",
      "    // Overload << operator to output",
      "    // BigInteger object",
      "    friend ostream& operator<<(ostream& out, const BigInteger& b) {",
      "        out << b.str;",
      "        return out;",
      "    }",
      "};"
    ],
    "description": "time complexity O(n^2) for multiplication, O(n) for addition and subtraction"
  },
  // ------------------------Data Structure End------------------------ //
  // ---------------------------Graph Start---------------------------- //
  //TODO: DFS code
  "Dfs code": {
    "prefix": "dfs_code",
    "body": [
      "map<int, vector<int>> adj;",
      "map<int, int> visited, parent, level, color;",
      "",
      "void dfs(int start) {",
      "    visited[start] = 1;",
      "    for (auto child : adj[start]) {",
      "        if (!visited[child]) {",
      "            dfs(child);",
      "        }",
      "    }",
      "    visited[start] = 2;",
      "}",
      "",
    ],
    "description": "time complexity O(V+E)"
  },
  //TODO: BFS code
  "BFS code": {
    "prefix": "bfs_code",
    "body": [
      "map<int, vector<int>> adj;",
      "map<int, int> visited, parent, level, color;",
      "",
      "void bfs(int start) {",
      "    queue<int> q;",
      "    q.push(start);",
      "    visited[start] = 1;",
      "    while (!q.empty()) {",
      "        int k = q.front();",
      "        q.pop();",
      "        for (auto child : adj[k]) {",
      "            if (!visited[child]) {",
      "                q.push(child);",
      "                visited[child] = 1;",
      "                visited[child] = 1;",
      "                level[child] = level[k] + 1;",
      "            }",
      "        }",
      "    }",
      "}",
      "",
    ],
    "description": "time complexity O(V+E)"
  },
  "Dijkstra Algorithm": {
    "prefix": "Dijkstra",
    "body": [
      "typedef pair<int, int> pairi;",
      "int N = 20000 + 5;",
      "vector<vector<pairi>> adj(N);",
      "vector<int> dis(N, inf), parent(N);",
      "",
      "void dijkstra(int src) {",
      "    priority_queue<pairi, vector<pairi>, greater<pairi>> pq;",
      "    dis[src] = 0;",
      "    pq.push({0, src});",
      "    while (pq.size()) {",
      "        auto top = pq.top();",
      "        pq.pop();",
      "        for (auto i : adj[top.second]) {",
      "            int v = i.first;",
      "            int wt = i.second;",
      "            if (dis[v] > dis[top.second] + wt) {",
      "                dis[v] = dis[top.second] + wt;",
      "                pq.push({dis[v], v});",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "time complexity O(V + ElogV)"
  },
  //TODO: Disjoint Set Union
  "Disjoint Set Union": {
    "prefix": "DSU",
    "body": [
      "class DisjointSet {",
      "    vector<int> parent, size, minElement, maxElement, cntElement;",
      "   public:",
      "    DisjointSet(int n) {",
      "        parent.resize(n + 1);",
      "        size.resize(n + 1, 1);",
      "        minElement.resize(n + 1);",
      "        maxElement.resize(n + 1);",
      "        cntElement.resize(n + 1, 1);",
      "        for (int i = 1; i <= n; i++)",
      "            parent[i] = minElement[i] = maxElement[i] = i;",
      "    }",
      "    int findUPar(int u) {",
      "        if (u == parent[u])",
      "            return u;",
      "        return parent[u] = findUPar(parent[u]);",
      "    }",
      "    void unionBySize(int u, int v) {",
      "        int pU = findUPar(u);",
      "        int pV = findUPar(v);",
      "        if (pU == pV)",
      "            return;",
      "        if(size[pU] < size[pV])",
      "            swap(pU, pV);",
      "        parent[pV] = pU;",
      "        size[pU] += size[pV];",
      "        cntElement[pU] += cntElement[pV];",
      "        minElement[pU] = min(minElement[pU], minElement[pV]);",
      "        maxElement[pU] = max(maxElement[pU], maxElement[pV]);",
      "    }",
      "    int getMinElementIntheSet(int u) { return minElement[findUPar(u)]; }",
      "    int getMaxElementIntheSet(int u) { return maxElement[findUPar(u)]; }",
      "    int getNumofElementIntheSet(int u) { return cntElement[findUPar(u)]; }",
      "};",
    ],
    "description": "time complexity O(logn) or O(1)"
  },
}